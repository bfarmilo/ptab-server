const redis = require('promise-redis')();
const config = require('./config.json');

const client = redis.createClient({
  host: config.database.server
});

client.on('connect', () => console.log('connected'));
client.on('error', err => console.log(err));



const survivalAnalysis = (showConsole = false) => {
  return client.smembers('binValues')
    .then(bins => {
      return client.multi()
        .zcard(`out:${bins[0].match(/_(.*)/)[1]}`)
        .zcard(`out:${bins[1].match(/_(.*)/)[1]}`)
        .zcard(`out:${bins[2].match(/_(.*)/)[1]}`)
        .zcard(`out:${bins[3].match(/_(.*)/)[1]}`)
        .zcard(`out:${bins[4].match(/_(.*)/)[1]}`)
        .zcard('uniqueClaims')
        .llen('allClaims')
        .exec()
        .then(results => {
          const totalClaims = results.pop();
          const uniqueClaims = results.pop();
          const survival = [];
          for (let i = 0; i < results.length; i += 1) {
            survival.push({ type: bins[i], count: results[i] })
          }
          if (showConsole) {
            console.log('Total claims: %s', totalClaims);
            console.log('Unique claims: %d', uniqueClaims);
            console.log('Claim Survival Count\n%j', survival.map(item => `${item.type}: ${item.count}`));
            console.log('%j', survival.map(item => `${item.type}: ${Math.round(1000 * (item.count / uniqueClaims)) / 10}%`));
          }
          return Promise.resolve('OK')
        })
        .catch(err => Promise.reject(err))
    }

deDuplicate((err2, data) => {
      survivalAnalysis((err3, done2) => {
        if (err3) throw err3;
        client.zrange('unpatentable', 0, -1, 'WITHSCORES')
          .then(rangeResult => convertZtoS(rangeResult, 'temp:unpat'))
          .then(newData => client.zrange('unpatentable_claim', 0, -1, 'WITHSCORES'))
          .then(rangeResult2 => convertZtoS(rangeResult2, 'temp:unpat_claim'))
          .then(newData => client.sdiffstore('doublecount', 'temp:unpat_claim', 'temp:unpat'))
          .then(numAdded => {
            console.log('merged %d records into %s', numAdded, 'doublecount');
            return byClassCode()
          })
          .then(sample => {
            // console.log(sample);
            return scanNext(sample, 'killed:300')
          })
          .then(sample => {
            // console.log(sample);
            client.quit();
          })
          .catch(err2 => {
            client.quit();
            throw err2;
          });

      });
    });

  const convertZtoS = (inputTable, outputTable) => {
    // takes a result array [val, score] 
    // generated by zrange('table', 0, -1, 'WITHSCORES')
    // to a new table {key} containing only scores
    return client.zrange(inputTable, 0, -1, 'WITHSCORES')
      .then(result => {
        let index = true;
        console.log('creating new table %s', key);
        return keyList = result.reduce((accum, item) => {
          if (index) {

          } else {
            accum.push(['sadd', key, `claimID:${item}`])
          }
          index = !index;
          return accum
        }, []);
      })
      .then(multiList => multiList.concat(['smembers', key]))
      .then(cmdList => client.multi(cmdList).exec())
      .catch(err => Promise.reject(err))
  }

  const byClassCode = () => {
    return client.zrange('survival:5_killed', 0, -1, 'WITHSCORES')
      .then(rangeResult => convertZtoS(rangeResult, 'temp:killed'))
      .then(killed => {
        const result = killed.pop();
        const output = result.map(item => ['hmget', `${item}`, 'Patent', 'Claim'])
        return client.multi(output).exec()
      })
      .then(dat => {
        // dat is now temp:killed converted into claimID's
        console.log('merging results')
        const merge = [
          ['sinterstore', 'killed:300', 'class:300', 'temp:killed'],
          ['sinterstore', 'killed:700', 'temp:killed', 'class:700'],
          ['sunionstore', 'killed:electronics', 'killed:300', 'killed:700']
        ]
        return client.multi(merge).exec()
      })
      .then(done => scanNext([0, 0], 'killed:300'))
  }

  const scanNext = (recordList, key) => {
    // expects an array of claim ID's in the form \d{1-5} or claimID:\d{1-5}
    // and the last element the cursor
    return client.sscan(key, recordList.pop())
      .then(scanResult => returnRecords(scanResult))
  }

  const returnRecords = (recordList) => {
    console.log('returnRecords called with %s records', recordList[1].length);
    let query = [];
    if (recordList[1][0].match("claimID")) {
      query = recordList[1].map(item => ['hgetall', `${item}`])
    } else {
      query = recordList[1].map(item => ['hgetall', `claimID:${item}`]);
    }
    return client.multi(query).exec()
      .then(output => output.concat(recordList[0]))
  }
}